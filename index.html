<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DROID-RAID Swarm Simulation with Global Optimization</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #fff1eb;
    }
    .info {
      font-family: sans-serif;
      color: #543D5E;
    }
  </style>
</head>
<body>
  <h1>DROID-RAID Proof of Concept v1.2</h1>
  <div class="info">
    <p>FPS: <span data-fps>60</span></p>
    <p>Drone Count: <span data-count>10</span></p>
  </div>
  
  <canvas id="swarmCanvas"></canvas>

  <script>
    // Constants
    const DRONE_COUNT = 10;
    const RADIUS = 80; // Distance drones maintain around the adversary
    const DRONE_SIZE = 8; // Default size for drones
    const COLLISION_DISTANCE = 20; // Distance to trigger z-direction movement
    const MAX_SCALE = 1.5; // Max scale to grow when avoiding collision
    const MIN_SCALE = 0.5; // Min scale when moving to avoid collisions
    const CORRECTIVE_FORCE_SCALE = 0.05; // Corrective force
    const DAMPING_FACTOR = 0.95; // Damping factor to reduce oscillation
    const canvas = document.getElementById('swarmCanvas');
    const ctx = canvas.getContext('2d');

    // Drones setup
    const drones = [];
    const threat = [0, 0]; // Adversary position
    let threatSpeed = 3; // Reduced movement speed for realism

    // Store available target positions
    let availableTargets = [];

    // Arrow key control
    let keys = {
      ArrowUp: false,
      ArrowDown: false,
      ArrowLeft: false,
      ArrowRight: false
    };

    document.addEventListener('keydown', (e) => {
      if (e.key in keys) keys[e.key] = true;
    });

    document.addEventListener('keyup', (e) => {
      if (e.key in keys) keys[e.key] = false;
    });

    // Setup canvas size
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initializeDrones(); // Re-initialize drones when resizing the screen
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Initialize drones and target positions
    function initializeDrones() {
      drones.length = 0;
      availableTargets.length = 0;
      const angleIncrement = (2 * Math.PI) / DRONE_COUNT;

      // Calculate the initial target positions (circular pattern)
      for (let i = 0; i < DRONE_COUNT; i++) {
        const angle = i * angleIncrement;
        const targetX = threat[0] + Math.cos(angle) * RADIUS;
        const targetY = threat[1] + Math.sin(angle) * RADIUS;
        availableTargets.push({ x: targetX, y: targetY, occupied: false });

        drones.push({
          angle,
          x: threat[0] + Math.random() * 100 - 50, // Randomize starting position
          y: threat[1] + Math.random() * 100 - 50, // Randomize starting position
          vx: 0, // Velocity in X direction
          vy: 0, // Velocity in Y direction
          mass: 0.25, // Set mass for hobbyist drones
          scale: 1.0, // Initial scale
          correctiveForce: CORRECTIVE_FORCE_SCALE * (0.9 + Math.random() * 0.2), // +/-10% variation
          targetIndex: i // Initially assign each drone to a target position
        });
      }

      // Place the adversary in the center of the canvas
      threat[0] = canvas.width / 2;
      threat[1] = canvas.height / 2;
    }

    // FPS management and UI
    let fpsCounter = 60;
    let frameText = document.querySelector('[data-fps]');
    let countText = document.querySelector('[data-count]');
    
    function updateFPS(rate) {
      fpsCounter = rate;
      frameText.textContent = Math.round(rate);
      countText.textContent = drones.length;
    }

    // Move the threat (adversary) using arrow keys
    function updateThreat() {
      if (keys.ArrowUp) threat[1] -= threatSpeed;
      if (keys.ArrowDown) threat[1] += threatSpeed;
      if (keys.ArrowLeft) threat[0] -= threatSpeed;
      if (keys.ArrowRight) threat[0] += threatSpeed;

      // Keep threat within canvas bounds
      threat[0] = Math.max(0, Math.min(canvas.width, threat[0]));
      threat[1] = Math.max(0, Math.min(canvas.height, threat[1]));
    }

    // Function to dynamically reassign drones based on global optimization
    function reassignDrones() {
      // Update availableTargets based on the new position of the adversary
      const angleIncrement = (2 * Math.PI) / DRONE_COUNT;
      availableTargets.forEach((target, i) => {
        const angle = i * angleIncrement;
        target.x = threat[0] + Math.cos(angle) * RADIUS;
        target.y = threat[1] + Math.sin(angle) * RADIUS;
        target.occupied = false; // Reset occupation status
      });

      // Calculate total cost (distance) for each drone to each available position
      let assignments = new Array(DRONE_COUNT).fill(null); // Track which target is assigned to each drone

      // Calculate the cost (distance) of every drone to every target
      let costs = drones.map(drone => {
        return availableTargets.map(target => Math.hypot(drone.x - target.x, drone.y - target.y));
      });

      // Assign drones to targets using a greedy algorithm
      for (let i = 0; i < DRONE_COUNT; i++) {
        let bestDroneIndex = null;
        let bestTargetIndex = null;
        let bestCost = Infinity;

        for (let d = 0; d < DRONE_COUNT; d++) {
          if (assignments[d] !== null) continue; // Skip drones that are already assigned
          for (let t = 0; t < DRONE_COUNT; t++) {
            if (availableTargets[t].occupied) continue; // Skip occupied targets
            if (costs[d][t] < bestCost) {
              bestCost = costs[d][t];
              bestDroneIndex = d;
              bestTargetIndex = t;
            }
          }
        }

        // Assign the best drone to the best target
        if (bestDroneIndex !== null && bestTargetIndex !== null) {
          assignments[bestDroneIndex] = bestTargetIndex;
          availableTargets[bestTargetIndex].occupied = true;
          drones[bestDroneIndex].targetIndex = bestTargetIndex;
        }
      }
    }

    // Drones logic with collision avoidance and global reassignment
    function tick() {
      updateThreat();
      reassignDrones();

      drones.forEach((drone, i) => {
        const target = availableTargets[drone.targetIndex];
        const targetX = target.x;
        const targetY = target.y;

        // Avoid collisions with other drones and the adversary
        let collisionDetected = false;

        // Check for collisions with the adversary
        const distanceToAdversary = Math.hypot(drone.x - threat[0], drone.y - threat[1]);
        if (distanceToAdversary < COLLISION_DISTANCE) {
          collisionDetected = true;
        }

        // Check for collisions with other drones
        drones.forEach((otherDrone, j) => {
          if (i !== j) {
            const distanceToDrone = Math.hypot(drone.x - otherDrone.x, drone.y - otherDrone.y);
            if (distanceToDrone < COLLISION_DISTANCE) {
              collisionDetected = true;
            }
          }
        });

        // Move up in z-direction (shrink) if collision is detected, otherwise move back to original scale
        if (collisionDetected) {
          drone.scale = Math.max(MIN_SCALE, drone.scale - 0.05); // Shrink the drone to avoid collision
        } else {
          drone.scale = Math.min(1.0, drone.scale + 0.02); // Return to normal size
        }

        // Apply corrective force to maintain formation
        drone.vx += (targetX - drone.x) * drone.correctiveForce / drone.mass;
        drone.vy += (targetY - drone.y) * drone.correctiveForce / drone.mass;

        // Update position
        drone.x += drone.vx;
        drone.y += drone.vy;

        // Apply stronger damping (drag) to reduce velocity and prevent overshoot
        drone.vx *= DAMPING_FACTOR;
        drone.vy *= DAMPING_FACTOR;
      });
    }

    // Draw function for canvas
    function draw() {
      // Clear the canvas
      ctx.fillStyle = 'rgba(255,241,235,1)'; // No trails in this version
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw the threat (red circle)
      ctx.fillStyle = '#FF0000';
      ctx.beginPath();
      ctx.arc(threat[0], threat[1], 12, 0, Math.PI * 2, false); // Adjust size for adversary drone
      ctx.fill();

      // Draw drones (in geometric pattern around the adversary)
      drones.forEach((drone) => {
        ctx.save();
        ctx.translate(drone.x, drone.y);
        ctx.scale(drone.scale, drone.scale); // Apply the scaling to simulate z-direction
        ctx.fillStyle = '#FFD700'; // Bright yellow color for drones
        ctx.fillRect(-DRONE_SIZE / 2, -DRONE_SIZE / 2, DRONE_SIZE, DRONE_SIZE); // Adjust position to center the drone
        ctx.restore();
      });
    }

    // Animation loop
    function animate() {
      tick();
      draw();
      requestAnimationFrame(animate);
    }

    animate(); // Start the animation loop

    // Track frame rate
    let lastFrameTime = Date.now();
    setInterval(function() {
      const now = Date.now();
      const deltaTime = now - lastFrameTime;
      lastFrameTime = now;
      const fps = 1000 / deltaTime;
      updateFPS(fps);
    }, 1000 / 60); // Updates roughly every second
  </script>
</body>
</html>
