<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DROID-RAID POC: Boids with Leader</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
        }

        /* Existing styles */

        #controlPanel {
            position: absolute;
            top: 10px;
            left: 10px;
            max-width: 250px;
            background: rgba(255, 255, 255, 0.8);
            padding: 0;
            border-radius: 8px;
            z-index: 10;
            font-family: Arial, sans-serif;
            color: #000;
        }

        #controlPanel summary {
            list-style: none;
            padding: 10px;
            cursor: pointer;
            font-weight: bold;
            background-color: #f0f0f0;
            margin: 0;
            border-radius: 8px;
        }

        #controlPanel summary::-webkit-details-marker {
            display: none;
        }

        #controlPanel summary::after {
            content: '▼';
            float: right;
            font-size: 12px;
        }

        #controlPanel[open] summary::after {
            content: '▲';
        }

        #controlPanel>* {
            padding: 10px;
        }

        #controlPanel label {
            display: block;
            margin-top: 10px;
        }

        #controlPanel input[type="range"] {
            width: 100%;
        }

        #title {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            font-weight: bold;
            z-index: 15;
            /* Ensure it appears above other elements */
            background-color: rgba(0, 0, 0, 0.5);
            /* Optional: Semi-transparent background for readability */
            padding: 5px 10px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <canvas id="swarmCanvas"></canvas>
    <div id="title">DROID-RAID Proof of Concept v2.1</div>
    <details id="controlPanel">
        <summary>Boid Parameters</summary>
        <label>
            Separation Weight: <span id="separationValue">1.5</span>
            <input type="range" id="separationSlider" min="0" max="5" step="0.1" value="1.5">
        </label>
        <label>
            Alignment Weight: <span id="alignmentValue">1.0</span>
            <input type="range" id="alignmentSlider" min="0" max="5" step="0.1" value="1.0">
        </label>
        <label>
            Cohesion Weight: <span id="cohesionValue">2.0</span>
            <input type="range" id="cohesionSlider" min="0" max="2" step="0.1" value="2.0">
        </label>
        <label>
            Perception Radius: <span id="perceptionValue">50</span>
            <input type="range" id="perceptionSlider" min="10" max="200" step="1" value="50">
        </label>
        <label>
            Wall Avoidance Weight: <span id="wallAvoidanceValue">10.0</span>
            <input type="range" id="wallAvoidanceSlider" min="0.1" max="10" step="0.1" value="10.0">
        </label>
        <label>
            Obstacle Avoidance Weight: <span id="obstacleAvoidanceValue">10.0</span>
            <input type="range" id="obstacleAvoidanceSlider" min="0.1" max="10" step="0.1" value="10.0">
        </label>
        <label>
            Maximum Speed: <span id="maxSpeedValue">4</span>
            <input type="range" id="maxSpeedSlider" min="1" max="10" step="0.1" value="4">
        </label>
        <label>
            Maximum Force: <span id="maxForceValue">0.2</span>
            <input type="range" id="maxForceSlider" min="0.01" max="2" step="0.01" value="0.2">
        </label>
        <label>
            <input type="checkbox" id="showPerceptionCheckbox" checked>
            Show Perception Radius
        </label>
        <label>
            <input type="checkbox" id="followTheLeaderCheckbox" checked>
            Follow The Leader
        </label>
    </details>
    <script>

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Update canvas dimensions in each boid
            boids.forEach(boid => {
                boid.canvasWidth = canvas.width;
                boid.canvasHeight = canvas.height;
            });
        });

        // Get references to the sliders and value displays
        const separationSlider = document.getElementById('separationSlider');
        const alignmentSlider = document.getElementById('alignmentSlider');
        const cohesionSlider = document.getElementById('cohesionSlider');
        const perceptionSlider = document.getElementById('perceptionSlider');
        const maxSpeedSlider = document.getElementById('maxSpeedSlider');
        const maxForceSlider = document.getElementById('maxForceSlider');
        const wallAvoidanceSlider = document.getElementById('wallAvoidanceSlider');
        const obstacleAvoidanceSlider = document.getElementById('obstacleAvoidanceSlider');

        const separationValue = document.getElementById('separationValue');
        const alignmentValue = document.getElementById('alignmentValue');
        const cohesionValue = document.getElementById('cohesionValue');
        const perceptionValue = document.getElementById('perceptionValue');
        const maxSpeedValue = document.getElementById('maxSpeedValue');
        const maxForceValue = document.getElementById('maxForceValue');
        const wallAvoidanceValue = document.getElementById('wallAvoidanceValue');
        const obstacleAvoidanceValue = document.getElementById('obstacleAvoidanceValue');

        class Boid {
            constructor(x, y, canvasWidth, canvasHeight) {
                this.color = "green"; // color
                this.position = { x, y }; // Boid's current position
                this.velocity = { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 }; // Random initial velocity
                this.acceleration = { x: 0, y: 0 }; // Acceleration vector
                this.orientation = Math.atan2(this.velocity.y, this.velocity.x); // Initial orientation
                this.perceptionRadius = 50; // Radius to detect neighbors
                this.perceptionBufferFactor = 1.0618;
                this.maxSpeed = 4; // Maximum speed
                this.maxForce = 0.1; // Maximum steering force
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
            }

            // Add a force to the boid's acceleration
            applyForce(force) {
                this.acceleration.x += force.x;
                this.acceleration.y += force.y;
            }

            separation(boids) {
                const desiredSeparation = 25.0; // Minimum desired separation between boids
                const steer = { x: 0, y: 0 };
                let total = 0;

                boids.forEach(other => {
                    const dx = this.position.x - other.position.x;
                    const dy = this.position.y - other.position.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (other !== this && distance > 0 && distance < desiredSeparation) {
                        // Calculate vector pointing away from neighbor, weighted by distance
                        const diff = {
                            x: dx / (distance * distance),
                            y: dy / (distance * distance)
                        };
                        steer.x += diff.x;
                        steer.y += diff.y;
                        total++;
                    }
                });

                if (total > 0) {
                    // Average the steering force
                    steer.x /= total;
                    steer.y /= total;

                    // Normalize and scale to maxForce
                    const magnitude = Math.sqrt(steer.x * steer.x + steer.y * steer.y);
                    if (magnitude > 0) {
                        steer.x = (steer.x / magnitude) * this.maxForce;
                        steer.y = (steer.y / magnitude) * this.maxForce;
                    }
                }

                return steer;
            }


            alignment(boids) {
                const steer = { x: 0, y: 0 };
                let total = 0;

                boids.forEach(other => {
                    const distance = Math.sqrt(
                        (this.position.x - other.position.x) ** 2 +
                        (this.position.y - other.position.y) ** 2
                    );

                    if (other !== this && distance < this.perceptionRadius) {
                        steer.x += other.velocity.x;
                        steer.y += other.velocity.y;
                        steer.x += Math.cos(other.orientation); // Use neighbor's orientation
                        steer.y += Math.sin(other.orientation);
                        total++;
                    }
                });

                if (total > 0) {
                    steer.x /= total;
                    steer.y /= total;

                    // Normalize and scale to maxForce
                    const magnitude = Math.sqrt(steer.x ** 2 + steer.y ** 2);
                    if (magnitude > 0) {
                        steer.x = (steer.x / magnitude) * this.maxForce;
                        steer.y = (steer.y / magnitude) * this.maxForce;
                    }
                }

                return steer;
            }

            cohesion(boids) {
                const steer = { x: 0, y: 0 };
                let total = 0;

                boids.forEach(other => {
                    const distance = Math.sqrt(
                        (this.position.x - other.position.x) ** 2 +
                        (this.position.y - other.position.y) ** 2
                    );

                    if (other !== this && distance < this.perceptionRadius) {
                        steer.x += other.position.x;
                        steer.y += other.position.y;
                        total++;
                    }
                });

                if (total > 0) {
                    steer.x /= total;
                    steer.y /= total;

                    // Steer toward the average position
                    steer.x = steer.x - this.position.x;
                    steer.y = steer.y - this.position.y;

                    // Normalize and scale to maxForce
                    const magnitude = Math.sqrt(steer.x ** 2 + steer.y ** 2);
                    if (magnitude > 0) {
                        steer.x = (steer.x / magnitude) * this.maxForce;
                        steer.y = (steer.y / magnitude) * this.maxForce;
                    }
                }

                return steer;
            }

            avoidObstacles(obstacles) {
                const steer = { x: 0, y: 0 };
                let imminentCollision = false;

                obstacles.forEach(obstacle => {
                    const dx = this.position.x - obstacle.x;
                    const dy = this.position.y - obstacle.y;
                    const distance = Math.sqrt(dx ** 2 + dy ** 2);

                    if (distance < (this.perceptionRadius * this.perceptionBufferFactor)) {
                        // Compute Gaussian influence
                        const influence = obstacle.amplitude * Math.exp(-((distance ** 2) / (2 * obstacle.sigma ** 2)));

                        // Define critical threshold
                        const criticalThreshold = 0.38 * obstacle.amplitude;

                        if (influence > criticalThreshold) {
                            // Imminent collision detected
                            imminentCollision = true;

                            // Apply hard repulsion
                            steer.x += (dx / distance) * this.maxForce * 8;
                            steer.y += (dy / distance) * this.maxForce * 8;
                        } else {
                            // Scale smooth Gaussian avoidance force by local risk
                            const localRisk = this.calculateLocalRisk([], obstacles).risk;
                            steer.x += ((1 + localRisk) * influence) * (dx / distance);
                            steer.y += ((1 + localRisk) * influence) * (dy / distance);
                        }
                    }
                });

                // Normalize and scale to maxForce
                const magnitude = Math.sqrt(steer.x ** 2 + steer.y ** 2);
                if (magnitude > 0) {
                    steer.x = (steer.x / magnitude) * this.maxForce;
                    steer.y = (steer.y / magnitude) * this.maxForce;
                }

                // Apply velocity scaling if imminent collision
                if (imminentCollision) {
                    const influence = Math.max(0, steer.x ** 2 + steer.y ** 2);
                    const criticalThreshold = 0.5 * Math.max(...obstacles.map(o => o.amplitude));
                    const scalingFactor = 1 - Math.min(1, influence / criticalThreshold);

                    // Scale velocity and acceleration
                    this.velocity.x *= scalingFactor;
                    this.velocity.y *= scalingFactor;
                    this.acceleration.x *= scalingFactor;
                    this.acceleration.y *= scalingFactor;
                }

                return steer;
            }

            flock(agents, obstacles) {
                const localRiskData = this.calculateLocalRisk(agents, obstacles);
                const localRisk = localRiskData.risk;

                // Get weights from sliders
                const separationWeight = parseFloat(separationSlider.value);
                const wallAvoidanceWeight = parseFloat(wallAvoidanceSlider.value);
                const obstacleAvoidanceWeight = parseFloat(obstacleAvoidanceSlider.value);
                const followForceWeight = 1.0;

                // Decrease alignment and cohesion weights in high-risk areas
                const alignmentWeight = parseFloat(alignmentSlider.value) * (1 - Math.min(localRisk / 10, 0.8));
                const cohesionWeight = parseFloat(cohesionSlider.value) * (1 - Math.min(localRisk / 10, 0.8));

                const separationForce = this.separation(agents);
                const alignmentForce = this.alignment(agents);
                const cohesionForce = this.cohesion(agents);
                const obstacleAvoidanceForce = this.avoidObstacles(obstacles);

                const wallAvoidanceForce = this.avoidWalls();
                const followForce = this.followLeader(leader);

                this.applyForce({
                    x: separationForce.x * parseFloat(separationSlider.value),
                    y: separationForce.y * parseFloat(separationSlider.value)
                });

                this.applyForce({
                    x: alignmentForce.x * alignmentWeight,
                    y: alignmentForce.y * alignmentWeight
                });

                this.applyForce({
                    x: cohesionForce.x * cohesionWeight,
                    y: cohesionForce.y * cohesionWeight
                });

                this.applyForce({
                    x: obstacleAvoidanceForce.x * parseFloat(obstacleAvoidanceSlider.value),
                    y: obstacleAvoidanceForce.y * parseFloat(obstacleAvoidanceSlider.value)
                });

                this.applyForce({
                    x: wallAvoidanceForce.x * wallAvoidanceWeight,
                    y: wallAvoidanceForce.y * wallAvoidanceWeight
                });

                if (followTheLeaderCheckbox.checked && !this.isLeader) {
                    const dx = leader.position.x - this.position.x;
                    const dy = leader.position.y - this.position.y;
                    this.orientation = Math.atan2(dy, dx); // Angle pointing toward the leader
                    this.applyForce({
                        x: followForce.x * followForceWeight,
                        y: followForce.y * followForceWeight
                    });
                };
            }

            avoidWalls() {
                const repulsionRadius = 50; // Distance at which walls start repelling boids
                const repulsionStrength = this.maxForce; // Use maxForce for scaling
                let force = { x: 0, y: 0 };

                // Left Wall
                if (this.position.x < repulsionRadius) {
                    force.x += (repulsionRadius - this.position.x) / repulsionRadius * repulsionStrength;
                }

                // Right Wall
                if (this.position.x > this.canvasWidth - repulsionRadius) {
                    force.x -= (this.position.x - (this.canvasWidth - repulsionRadius)) / repulsionRadius * repulsionStrength;
                }

                // Top Wall
                if (this.position.y < repulsionRadius) {
                    force.y += (repulsionRadius - this.position.y) / repulsionRadius * repulsionStrength;
                }

                // Bottom Wall
                if (this.position.y > this.canvasHeight - repulsionRadius) {
                    force.y -= (this.position.y - (this.canvasHeight - repulsionRadius)) / repulsionRadius * repulsionStrength;
                }

                return force;
            }

            followLeader(leader) {
                const desiredSeparation = 50; // Adjust as needed
                const steer = {
                    x: leader.position.x - this.position.x,
                    y: leader.position.y - this.position.y
                };

                const distance = Math.sqrt(steer.x ** 2 + steer.y ** 2);

                if (distance < desiredSeparation) {
                    // If too close, create a repulsive force
                    steer.x = -steer.x;
                    steer.y = -steer.y;
                }

                // Normalize and scale to maxForce
                const magnitude = Math.sqrt(steer.x ** 2 + steer.y ** 2);
                if (magnitude > 0) {
                    steer.x = (steer.x / magnitude) * this.maxForce;
                    steer.y = (steer.y / magnitude) * this.maxForce;
                }

                return steer;
            }


            // Update position and velocity
            update() {

                // Update perceptionRadius, maxSpeed, maxForce from sliders
                this.perceptionRadius = parseFloat(perceptionSlider.value);
                this.maxSpeed = parseFloat(maxSpeedSlider.value);
                this.maxForce = parseFloat(maxForceSlider.value);
                this.velocity.x += this.acceleration.x;
                this.velocity.y += this.acceleration.y;

                // Limit the velocity to the maximum speed
                const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
                if (speed > this.maxSpeed) {
                    this.velocity.x = (this.velocity.x / speed) * this.maxSpeed;
                    this.velocity.y = (this.velocity.y / speed) * this.maxSpeed;
                }

                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;

                // Update orientation based on velocity
                this.updateOrientation();

                // Reset acceleration after each update
                this.acceleration.x = 0;
                this.acceleration.y = 0;
            }

            updateLedger(index) {
                ledger.boids[index] = {
                    position: { x: this.position.x, y: this.position.y },
                    velocity: { x: this.velocity.x, y: this.velocity.y },
                    orientation: Math.atan2(this.velocity.y, this.velocity.x)
                };
            }

            // Update orientation based on velocity
            updateOrientation() {
                const targetOrientation = Math.atan2(this.velocity.y, this.velocity.x);
                const angleDifference = targetOrientation - this.orientation;

                // Normalize angleDifference to [-PI, PI]
                const normalizedDifference = Math.atan2(
                    Math.sin(angleDifference),
                    Math.cos(angleDifference)
                );

                // Apply smoothing factor to avoid abrupt changes
                const smoothingFactor = 0.1; // Adjust for smoothness
                this.orientation += normalizedDifference * smoothingFactor;

                // Normalize orientation to [-PI, PI]
                this.orientation = Math.atan2(
                    Math.sin(this.orientation),
                    Math.cos(this.orientation)
                );
            }

            calculateLocalRisk(agents, obstacles) {
                let totalRisk = 0;
                let nearbyAgents = 0;
                let nearbyObstacles = 0;

                // Evaluate nearby agents
                agents.forEach(other => {
                    if (other !== this) {
                        const dx = this.position.x - other.position.x;
                        const dy = this.position.y - other.position.y;
                        const distance = Math.sqrt(dx ** 2 + dy ** 2);

                        if (distance < this.perceptionRadius) {
                            nearbyAgents++;
                            const relativeVelocity = Math.sqrt(
                                (this.velocity.x - other.velocity.x) ** 2 +
                                (this.velocity.y - other.velocity.y) ** 2
                            );

                            // Risk contribution from agents
                            totalRisk += (1 / distance) * 2.0 + relativeVelocity * 1.0;
                        }
                    }
                });

                // Evaluate nearby obstacles
                ledger.obstacles.forEach(obstacle => {
                    const dx = this.position.x - obstacle.x;
                    const dy = this.position.y - obstacle.y;
                    const distance = Math.sqrt(dx ** 2 + dy ** 2);

                    if (distance < this.perceptionRadius) {
                        nearbyObstacles++;
                        const proximityFactor = (1 - distance / obstacle.sigma);

                        // Risk contribution from obstacles
                        totalRisk += (1 / distance) * 3.0 + proximityFactor * obstacle.amplitude * 2.0;
                    }
                });

                // Normalize risk by total objects in the vicinity
                const totalObjects = nearbyAgents + nearbyObstacles;
                if (totalObjects > 0) {
                    totalRisk /= totalObjects;
                }

                return {
                    risk: totalRisk,
                    agents: nearbyAgents,
                    obstacles: nearbyObstacles
                };
            }


        }

        class Leader extends Boid {
            constructor(x, y, canvasWidth, canvasHeight, color) {
                super(x, y, canvasWidth, canvasHeight, color);
                this.color = "blue";
                this.isLeader = true; // You can use true/false instead of 1/0
            }
        }

        const canvas = document.getElementById('swarmCanvas');
        const context = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;

        const obstacles = [
            { x: 150, y: 200, amplitude: 1.5, sigma: 50 },  // Example obstacle
            { x: 400, y: 300, amplitude: 1.0, sigma: 70 },  // Another obstacle
            { x: 600, y: 400, amplitude: 2.0, sigma: 30 }   // Smaller, sharper influence
        ];


        const leader = new Leader(Math.random() * canvasWidth, Math.random() * canvasHeight, canvasWidth, canvasHeight);

        const boids = [leader];

        // Initialize 9 more boids
        for (let i = 0; i < 9; i++) {
            boids.push(new Boid(Math.random() * canvasWidth, Math.random() * canvasHeight, canvasWidth, canvasHeight));
        }

        const ledger = {
            boids: [], // Array to store all drones (boids)
            obstacles: [] // Array to store all obstacle data
        };

        obstacles.forEach((obstacle, index) => {
            ledger.obstacles[index] = {
                position: { x: obstacle.x, y: obstacle.y },
                amplitude: obstacle.amplitude,
                sigma: obstacle.sigma
            };
        });

        const showPerceptionCheckbox = document.getElementById('showPerceptionCheckbox');
        const followTheLeaderCheckbox = document.getElementById('followTheLeaderCheckbox');

        // Update displayed slider values
        function updateSliderValues() {
            separationValue.textContent = separationSlider.value;
            alignmentValue.textContent = alignmentSlider.value;
            cohesionValue.textContent = cohesionSlider.value;
            perceptionValue.textContent = perceptionSlider.value;
            maxSpeedValue.textContent = maxSpeedSlider.value;
            maxForceValue.textContent = maxForceSlider.value;
            wallAvoidanceValue.textContent = wallAvoidanceSlider.value;
            obstacleAvoidanceValue.textContent = obstacleAvoidanceSlider.value;
        }

        // Add event listeners to sliders
        separationSlider.addEventListener('input', updateSliderValues);
        alignmentSlider.addEventListener('input', updateSliderValues);
        cohesionSlider.addEventListener('input', updateSliderValues);
        perceptionSlider.addEventListener('input', updateSliderValues);
        maxSpeedSlider.addEventListener('input', updateSliderValues);
        maxForceSlider.addEventListener('input', updateSliderValues);
        wallAvoidanceSlider.addEventListener('input', updateSliderValues);
        obstacleAvoidanceSlider.addEventListener('input', updateSliderValues);

        // Initial update of slider values
        updateSliderValues();


        function calculateHighRiskZones() {
            const riskZones = [];

            ledger.obstacles.forEach(obstacle => {
                let totalProximity = 0; // Sum of distances to boids
                let totalVelocity = 0; // Sum of relative velocities
                let boidCount = 0; // Number of boids in the risk zone

                ledger.boids.forEach(boid => {
                    const dx = boid.position.x - obstacle.position.x;
                    const dy = boid.position.y - obstacle.position.y;
                    const distance = Math.sqrt(dx ** 2 + dy ** 2);

                    // Check if boid is within the obstacle's influence radius
                    if (distance < obstacle.sigma) {
                        boidCount++;
                        totalProximity += distance;

                        // Calculate relative velocity
                        const relativeVelocity = Math.sqrt(
                            boid.velocity.x ** 2 + boid.velocity.y ** 2
                        );
                        totalVelocity += relativeVelocity;
                    }
                });

                if (boidCount > 0) {
                    const avgProximity = totalProximity / boidCount;
                    const avgVelocity = totalVelocity / boidCount;

                    // Weights for risk factors
                    const w_p = 2.0; // Weight for proximity
                    const w_d = 1.5; // Weight for density
                    const w_v = 1.0; // Weight for velocity

                    // Calculate severity
                    const severity = w_p * (1 / avgProximity) + w_d * boidCount + w_v * avgVelocity;

                    // Add the risk zone with severity
                    riskZones.push({
                        x: obstacle.position.x,
                        y: obstacle.position.y,
                        radius: obstacle.sigma,
                        severity: severity
                    });
                }
            });

            return riskZones;
        }

        function drawObstaclesWithGradient(context, obstacles) {
            obstacles.forEach(obstacle => {
                // Create radial gradient
                const gradient = context.createRadialGradient(
                    obstacle.x, obstacle.y, 0,
                    obstacle.x, obstacle.y, obstacle.sigma
                );
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0.5)');  // Strong influence
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');    // Fades out

                // Draw the influence area
                context.beginPath();
                context.arc(obstacle.x, obstacle.y, obstacle.sigma, 0, Math.PI * 2);
                context.fillStyle = gradient;
                context.fill();

                // Draw the obstacle core
                context.beginPath();
                context.arc(obstacle.x, obstacle.y, 10, 0, Math.PI * 2);
                context.fillStyle = 'red';
                context.fill();
            });
        }

        // Animation loop
        function animate() {
            // console.log(calculateHighRiskZones())
            context.clearRect(0, 0, canvas.width, canvas.height);

            boids.forEach((boid, index) => {
                boid.flock(boids, obstacles); // Apply flocking behaviors
                boid.update();     // Update position and velocity
                boid.updateLedger(index); // Update ledger with boid state

                drawOrientation(context, boid);


                // Draw the obstacles
                drawObstaclesWithGradient(context, obstacles);

                // Draw the boid
                context.beginPath();
                context.fillStyle = boid.color;
                context.arc(boid.position.x, boid.position.y, 3, 0, Math.PI * 2);
                context.fill();

                // Draw perception radius if checkbox is checked
                if (showPerceptionCheckbox.checked) {
                    context.beginPath();
                    context.strokeStyle = 'rgba(255, 255, 255, 0.5)'; // Semi-transparent white
                    context.lineWidth = 1;
                    context.setLineDash([5, 5]); // Dotted line: 5px dash, 5px gap
                    context.arc(boid.position.x, boid.position.y, boid.perceptionRadius, 0, Math.PI * 2);
                    context.stroke();
                    context.setLineDash([]); // Reset line dash
                }
            });

            requestAnimationFrame(animate);
        }

        animate();

        function drawOrientation(context, agent) {
            const arrowLength = 5; // Length of the orientation arrow
            const arrowX = agent.position.x + Math.cos(agent.orientation) * arrowLength;
            const arrowY = agent.position.y + Math.sin(agent.orientation) * arrowLength;

            context.beginPath();
            context.moveTo(agent.position.x, agent.position.y);
            context.lineTo(arrowX, arrowY);
            context.strokeStyle = 'white';
            context.lineWidth = 1;
            context.stroke();
        }


    </script>
</body>

</html>
